## Recursion 
- Sometimes it might be hard to pick the (first) base case, but once it has been chosen the logic for why that base case works should be pretty intuitive 
- - You don't have to write the base case first, but generally it's easier to do that first - Base case doesn't have to just check 1 number as well 
- - A recursive case must make progress towards a base case - You don't really think about how it gets there, but rather if it does make progress 
- - There are exceptions though: - Ex: Recursing over a list and splitting it in half each time - If the base case is len(list) == 0, then the list will be split into `[]` and `[element]`, `[element]` will be split again into `[]` and `[element]`, meaning that that list will infinitely recurse - Technically, you could replace a for loop with recursion, but that's generally not a good idea - For DFS, the recursive code for that is much simpler - Recursion is also with data structures with references inside its references and etc. - in nested reference data structures, you may need a deep copy - right way to implement deep copy (without it being super pain) - recursion - other form of copying is shallow copy - Built in copy functions: - for deep copies - import deepcopy from copy (python standard library) - for shallow copies - import copy from copy (python standard library) - In a for loop, you use a variable, finish it, and then keep using it - In recursion, every call gets that variable (scoped to that call) - every call gets a stack frame - local variable = variable in a stack frame - so every call gets its own local variable - In one of our examples, the value returned from the recursive call just gets stored in the stack frame above it - Assigning values to variables within the stack frames do not change the values of the variables in other stack frames with the same variable name (because those variables are locally scoped) > Shallow copy ![[Pasted image 20250318132352.png]] ### Half intervals `mid = len(list) // 2` `list[mid]`